// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: try.proto

#ifndef PROTOBUF_INCLUDED_try_2eproto
#define PROTOBUF_INCLUDED_try_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_try_2eproto 

namespace protobuf_try_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_try_2eproto
namespace NetProto {
class TryItem;
class TryItemDefaultTypeInternal;
extern TryItemDefaultTypeInternal _TryItem_default_instance_;
class TryMsg;
class TryMsgDefaultTypeInternal;
extern TryMsgDefaultTypeInternal _TryMsg_default_instance_;
}  // namespace NetProto
namespace google {
namespace protobuf {
template<> ::NetProto::TryItem* Arena::CreateMaybeMessage<::NetProto::TryItem>(Arena*);
template<> ::NetProto::TryMsg* Arena::CreateMaybeMessage<::NetProto::TryMsg>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace NetProto {

enum TryMsg_TryNestEnum {
  TryMsg_TryNestEnum_a = 0,
  TryMsg_TryNestEnum_b = 1,
  TryMsg_TryNestEnum_TryMsg_TryNestEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TryMsg_TryNestEnum_TryMsg_TryNestEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TryMsg_TryNestEnum_IsValid(int value);
const TryMsg_TryNestEnum TryMsg_TryNestEnum_TryNestEnum_MIN = TryMsg_TryNestEnum_a;
const TryMsg_TryNestEnum TryMsg_TryNestEnum_TryNestEnum_MAX = TryMsg_TryNestEnum_b;
const int TryMsg_TryNestEnum_TryNestEnum_ARRAYSIZE = TryMsg_TryNestEnum_TryNestEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TryMsg_TryNestEnum_descriptor();
inline const ::std::string& TryMsg_TryNestEnum_Name(TryMsg_TryNestEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TryMsg_TryNestEnum_descriptor(), value);
}
inline bool TryMsg_TryNestEnum_Parse(
    const ::std::string& name, TryMsg_TryNestEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TryMsg_TryNestEnum>(
    TryMsg_TryNestEnum_descriptor(), name, value);
}
enum TryEnum {
  a = 0,
  b = 1,
  TryEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TryEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TryEnum_IsValid(int value);
const TryEnum TryEnum_MIN = a;
const TryEnum TryEnum_MAX = b;
const int TryEnum_ARRAYSIZE = TryEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TryEnum_descriptor();
inline const ::std::string& TryEnum_Name(TryEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TryEnum_descriptor(), value);
}
inline bool TryEnum_Parse(
    const ::std::string& name, TryEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TryEnum>(
    TryEnum_descriptor(), name, value);
}
// ===================================================================

class TryItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetProto.TryItem) */ {
 public:
  TryItem();
  virtual ~TryItem();

  TryItem(const TryItem& from);

  inline TryItem& operator=(const TryItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TryItem(TryItem&& from) noexcept
    : TryItem() {
    *this = ::std::move(from);
  }

  inline TryItem& operator=(TryItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TryItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TryItem* internal_default_instance() {
    return reinterpret_cast<const TryItem*>(
               &_TryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(TryItem* other);
  void Swap(TryItem* other);
  friend void swap(TryItem& a, TryItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TryItem* New() const final {
    return CreateMaybeMessage<TryItem>(NULL);
  }

  TryItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TryItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TryItem& from);
  void MergeFrom(const TryItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryItem* other);
  protected:
  explicit TryItem(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NetProto.TryItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_try_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TryMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetProto.TryMsg) */ {
 public:
  TryMsg();
  virtual ~TryMsg();

  TryMsg(const TryMsg& from);

  inline TryMsg& operator=(const TryMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TryMsg(TryMsg&& from) noexcept
    : TryMsg() {
    *this = ::std::move(from);
  }

  inline TryMsg& operator=(TryMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TryMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TryMsg* internal_default_instance() {
    return reinterpret_cast<const TryMsg*>(
               &_TryMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(TryMsg* other);
  void Swap(TryMsg* other);
  friend void swap(TryMsg& a, TryMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TryMsg* New() const final {
    return CreateMaybeMessage<TryMsg>(NULL);
  }

  TryMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TryMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TryMsg& from);
  void MergeFrom(const TryMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryMsg* other);
  protected:
  explicit TryMsg(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TryMsg_TryNestEnum TryNestEnum;
  static const TryNestEnum a =
    TryMsg_TryNestEnum_a;
  static const TryNestEnum b =
    TryMsg_TryNestEnum_b;
  static inline bool TryNestEnum_IsValid(int value) {
    return TryMsg_TryNestEnum_IsValid(value);
  }
  static const TryNestEnum TryNestEnum_MIN =
    TryMsg_TryNestEnum_TryNestEnum_MIN;
  static const TryNestEnum TryNestEnum_MAX =
    TryMsg_TryNestEnum_TryNestEnum_MAX;
  static const int TryNestEnum_ARRAYSIZE =
    TryMsg_TryNestEnum_TryNestEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TryNestEnum_descriptor() {
    return TryMsg_TryNestEnum_descriptor();
  }
  static inline const ::std::string& TryNestEnum_Name(TryNestEnum value) {
    return TryMsg_TryNestEnum_Name(value);
  }
  static inline bool TryNestEnum_Parse(const ::std::string& name,
      TryNestEnum* value) {
    return TryMsg_TryNestEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NetProto.TryItem msg_array = 6;
  int msg_array_size() const;
  void clear_msg_array();
  static const int kMsgArrayFieldNumber = 6;
  ::NetProto::TryItem* mutable_msg_array(int index);
  ::google::protobuf::RepeatedPtrField< ::NetProto::TryItem >*
      mutable_msg_array();
  const ::NetProto::TryItem& msg_array(int index) const;
  ::NetProto::TryItem* add_msg_array();
  const ::google::protobuf::RepeatedPtrField< ::NetProto::TryItem >&
      msg_array() const;

  // repeated .NetProto.TryMsg.TryNestEnum nest_enum_array = 7;
  int nest_enum_array_size() const;
  void clear_nest_enum_array();
  static const int kNestEnumArrayFieldNumber = 7;
  ::NetProto::TryMsg_TryNestEnum nest_enum_array(int index) const;
  void set_nest_enum_array(int index, ::NetProto::TryMsg_TryNestEnum value);
  void add_nest_enum_array(::NetProto::TryMsg_TryNestEnum value);
  const ::google::protobuf::RepeatedField<int>& nest_enum_array() const;
  ::google::protobuf::RepeatedField<int>* mutable_nest_enum_array();

  // string str_val = 2;
  void clear_str_val();
  static const int kStrValFieldNumber = 2;
  const ::std::string& str_val() const;
  void set_str_val(const ::std::string& value);
  #if LANG_CXX11
  void set_str_val(::std::string&& value);
  #endif
  void set_str_val(const char* value);
  void set_str_val(const char* value, size_t size);
  ::std::string* mutable_str_val();
  ::std::string* release_str_val();
  void set_allocated_str_val(::std::string* str_val);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_str_val();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_str_val(
      ::std::string* str_val);

  // .NetProto.TryItem msg_val = 3;
  bool has_msg_val() const;
  void clear_msg_val();
  static const int kMsgValFieldNumber = 3;
  private:
  const ::NetProto::TryItem& _internal_msg_val() const;
  public:
  const ::NetProto::TryItem& msg_val() const;
  ::NetProto::TryItem* release_msg_val();
  ::NetProto::TryItem* mutable_msg_val();
  void set_allocated_msg_val(::NetProto::TryItem* msg_val);
  void unsafe_arena_set_allocated_msg_val(
      ::NetProto::TryItem* msg_val);
  ::NetProto::TryItem* unsafe_arena_release_msg_val();

  // int32 int_val = 1;
  void clear_int_val();
  static const int kIntValFieldNumber = 1;
  ::google::protobuf::int32 int_val() const;
  void set_int_val(::google::protobuf::int32 value);

  // .NetProto.TryEnum enum_val = 4;
  void clear_enum_val();
  static const int kEnumValFieldNumber = 4;
  ::NetProto::TryEnum enum_val() const;
  void set_enum_val(::NetProto::TryEnum value);

  // .NetProto.TryMsg.TryNestEnum nest_enum_val = 5;
  void clear_nest_enum_val();
  static const int kNestEnumValFieldNumber = 5;
  ::NetProto::TryMsg_TryNestEnum nest_enum_val() const;
  void set_nest_enum_val(::NetProto::TryMsg_TryNestEnum value);

  // @@protoc_insertion_point(class_scope:NetProto.TryMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::NetProto::TryItem > msg_array_;
  ::google::protobuf::RepeatedField<int> nest_enum_array_;
  mutable int _nest_enum_array_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr str_val_;
  ::NetProto::TryItem* msg_val_;
  ::google::protobuf::int32 int_val_;
  int enum_val_;
  int nest_enum_val_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_try_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TryItem

// int32 id = 1;
inline void TryItem::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 TryItem::id() const {
  // @@protoc_insertion_point(field_get:NetProto.TryItem.id)
  return id_;
}
inline void TryItem::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:NetProto.TryItem.id)
}

// string name = 2;
inline void TryItem::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TryItem::name() const {
  // @@protoc_insertion_point(field_get:NetProto.TryItem.name)
  return name_.Get();
}
inline void TryItem::set_name(const ::std::string& value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:NetProto.TryItem.name)
}
#if LANG_CXX11
inline void TryItem::set_name(::std::string&& value) {
  
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:NetProto.TryItem.name)
}
#endif
inline void TryItem::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:NetProto.TryItem.name)
}
inline void TryItem::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:NetProto.TryItem.name)
}
inline ::std::string* TryItem::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:NetProto.TryItem.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TryItem::release_name() {
  // @@protoc_insertion_point(field_release:NetProto.TryItem.name)
  
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TryItem::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:NetProto.TryItem.name)
}
inline ::std::string* TryItem::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:NetProto.TryItem.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TryItem::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetProto.TryItem.name)
}

// -------------------------------------------------------------------

// TryMsg

// int32 int_val = 1;
inline void TryMsg::clear_int_val() {
  int_val_ = 0;
}
inline ::google::protobuf::int32 TryMsg::int_val() const {
  // @@protoc_insertion_point(field_get:NetProto.TryMsg.int_val)
  return int_val_;
}
inline void TryMsg::set_int_val(::google::protobuf::int32 value) {
  
  int_val_ = value;
  // @@protoc_insertion_point(field_set:NetProto.TryMsg.int_val)
}

// string str_val = 2;
inline void TryMsg::clear_str_val() {
  str_val_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TryMsg::str_val() const {
  // @@protoc_insertion_point(field_get:NetProto.TryMsg.str_val)
  return str_val_.Get();
}
inline void TryMsg::set_str_val(const ::std::string& value) {
  
  str_val_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:NetProto.TryMsg.str_val)
}
#if LANG_CXX11
inline void TryMsg::set_str_val(::std::string&& value) {
  
  str_val_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:NetProto.TryMsg.str_val)
}
#endif
inline void TryMsg::set_str_val(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  str_val_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:NetProto.TryMsg.str_val)
}
inline void TryMsg::set_str_val(const char* value,
    size_t size) {
  
  str_val_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:NetProto.TryMsg.str_val)
}
inline ::std::string* TryMsg::mutable_str_val() {
  
  // @@protoc_insertion_point(field_mutable:NetProto.TryMsg.str_val)
  return str_val_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TryMsg::release_str_val() {
  // @@protoc_insertion_point(field_release:NetProto.TryMsg.str_val)
  
  return str_val_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TryMsg::set_allocated_str_val(::std::string* str_val) {
  if (str_val != NULL) {
    
  } else {
    
  }
  str_val_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str_val,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:NetProto.TryMsg.str_val)
}
inline ::std::string* TryMsg::unsafe_arena_release_str_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:NetProto.TryMsg.str_val)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return str_val_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TryMsg::unsafe_arena_set_allocated_str_val(
    ::std::string* str_val) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (str_val != NULL) {
    
  } else {
    
  }
  str_val_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      str_val, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetProto.TryMsg.str_val)
}

// .NetProto.TryItem msg_val = 3;
inline bool TryMsg::has_msg_val() const {
  return this != internal_default_instance() && msg_val_ != NULL;
}
inline void TryMsg::clear_msg_val() {
  if (GetArenaNoVirtual() == NULL && msg_val_ != NULL) {
    delete msg_val_;
  }
  msg_val_ = NULL;
}
inline const ::NetProto::TryItem& TryMsg::_internal_msg_val() const {
  return *msg_val_;
}
inline const ::NetProto::TryItem& TryMsg::msg_val() const {
  const ::NetProto::TryItem* p = msg_val_;
  // @@protoc_insertion_point(field_get:NetProto.TryMsg.msg_val)
  return p != NULL ? *p : *reinterpret_cast<const ::NetProto::TryItem*>(
      &::NetProto::_TryItem_default_instance_);
}
inline ::NetProto::TryItem* TryMsg::release_msg_val() {
  // @@protoc_insertion_point(field_release:NetProto.TryMsg.msg_val)
  
  ::NetProto::TryItem* temp = msg_val_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  msg_val_ = NULL;
  return temp;
}
inline ::NetProto::TryItem* TryMsg::unsafe_arena_release_msg_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:NetProto.TryMsg.msg_val)
  
  ::NetProto::TryItem* temp = msg_val_;
  msg_val_ = NULL;
  return temp;
}
inline ::NetProto::TryItem* TryMsg::mutable_msg_val() {
  
  if (msg_val_ == NULL) {
    auto* p = CreateMaybeMessage<::NetProto::TryItem>(GetArenaNoVirtual());
    msg_val_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NetProto.TryMsg.msg_val)
  return msg_val_;
}
inline void TryMsg::set_allocated_msg_val(::NetProto::TryItem* msg_val) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_val_;
  }
  if (msg_val) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(msg_val);
    if (message_arena != submessage_arena) {
      msg_val = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg_val, submessage_arena);
    }
    
  } else {
    
  }
  msg_val_ = msg_val;
  // @@protoc_insertion_point(field_set_allocated:NetProto.TryMsg.msg_val)
}

// .NetProto.TryEnum enum_val = 4;
inline void TryMsg::clear_enum_val() {
  enum_val_ = 0;
}
inline ::NetProto::TryEnum TryMsg::enum_val() const {
  // @@protoc_insertion_point(field_get:NetProto.TryMsg.enum_val)
  return static_cast< ::NetProto::TryEnum >(enum_val_);
}
inline void TryMsg::set_enum_val(::NetProto::TryEnum value) {
  
  enum_val_ = value;
  // @@protoc_insertion_point(field_set:NetProto.TryMsg.enum_val)
}

// .NetProto.TryMsg.TryNestEnum nest_enum_val = 5;
inline void TryMsg::clear_nest_enum_val() {
  nest_enum_val_ = 0;
}
inline ::NetProto::TryMsg_TryNestEnum TryMsg::nest_enum_val() const {
  // @@protoc_insertion_point(field_get:NetProto.TryMsg.nest_enum_val)
  return static_cast< ::NetProto::TryMsg_TryNestEnum >(nest_enum_val_);
}
inline void TryMsg::set_nest_enum_val(::NetProto::TryMsg_TryNestEnum value) {
  
  nest_enum_val_ = value;
  // @@protoc_insertion_point(field_set:NetProto.TryMsg.nest_enum_val)
}

// repeated .NetProto.TryItem msg_array = 6;
inline int TryMsg::msg_array_size() const {
  return msg_array_.size();
}
inline void TryMsg::clear_msg_array() {
  msg_array_.Clear();
}
inline ::NetProto::TryItem* TryMsg::mutable_msg_array(int index) {
  // @@protoc_insertion_point(field_mutable:NetProto.TryMsg.msg_array)
  return msg_array_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NetProto::TryItem >*
TryMsg::mutable_msg_array() {
  // @@protoc_insertion_point(field_mutable_list:NetProto.TryMsg.msg_array)
  return &msg_array_;
}
inline const ::NetProto::TryItem& TryMsg::msg_array(int index) const {
  // @@protoc_insertion_point(field_get:NetProto.TryMsg.msg_array)
  return msg_array_.Get(index);
}
inline ::NetProto::TryItem* TryMsg::add_msg_array() {
  // @@protoc_insertion_point(field_add:NetProto.TryMsg.msg_array)
  return msg_array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NetProto::TryItem >&
TryMsg::msg_array() const {
  // @@protoc_insertion_point(field_list:NetProto.TryMsg.msg_array)
  return msg_array_;
}

// repeated .NetProto.TryMsg.TryNestEnum nest_enum_array = 7;
inline int TryMsg::nest_enum_array_size() const {
  return nest_enum_array_.size();
}
inline void TryMsg::clear_nest_enum_array() {
  nest_enum_array_.Clear();
}
inline ::NetProto::TryMsg_TryNestEnum TryMsg::nest_enum_array(int index) const {
  // @@protoc_insertion_point(field_get:NetProto.TryMsg.nest_enum_array)
  return static_cast< ::NetProto::TryMsg_TryNestEnum >(nest_enum_array_.Get(index));
}
inline void TryMsg::set_nest_enum_array(int index, ::NetProto::TryMsg_TryNestEnum value) {
  nest_enum_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:NetProto.TryMsg.nest_enum_array)
}
inline void TryMsg::add_nest_enum_array(::NetProto::TryMsg_TryNestEnum value) {
  nest_enum_array_.Add(value);
  // @@protoc_insertion_point(field_add:NetProto.TryMsg.nest_enum_array)
}
inline const ::google::protobuf::RepeatedField<int>&
TryMsg::nest_enum_array() const {
  // @@protoc_insertion_point(field_list:NetProto.TryMsg.nest_enum_array)
  return nest_enum_array_;
}
inline ::google::protobuf::RepeatedField<int>*
TryMsg::mutable_nest_enum_array() {
  // @@protoc_insertion_point(field_mutable_list:NetProto.TryMsg.nest_enum_array)
  return &nest_enum_array_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NetProto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NetProto::TryMsg_TryNestEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetProto::TryMsg_TryNestEnum>() {
  return ::NetProto::TryMsg_TryNestEnum_descriptor();
}
template <> struct is_proto_enum< ::NetProto::TryEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetProto::TryEnum>() {
  return ::NetProto::TryEnum_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_try_2eproto
